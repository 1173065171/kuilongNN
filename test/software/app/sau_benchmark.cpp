#include "sau_benchmark.hpp"
#include "matrixA.hpp"
#include "matrixB.hpp"
#define SIZE 32
#define BLOCK_SIZE 16



void matrix_csr_set_test()
{
	ACENN_DEBUG("sau test once ins test start!");

	int a, b, c, d, e, f, r;
	a = 0x10144000;
	b = 0x10144400;
	c = 0x00004001;
	d = 0x10144800;
	e = 0x00000000;
	f = 0x00000001;


	__kuiloong_ace_msetins1(a, b);
	__kuiloong_ace_msetins2(c, d);
	__kuiloong_ace_msetins3(e, f);
	r = __kuiloong_ace_mgetins3lsb();
	if (r != f) {
		ACENN_DEBUG("Read %x", r);
		ACENN_DEBUG("SAU failed to set %x", f);
		asm("ebreak;");
	}
	ACENN_DEBUG("matrix once ins test PASS!");
}


//单次16X16与16X16的矩阵乘
void minimum_matmul_single_1(int8_t *input_block1, int8_t *input_block2, int8_t *output_block3) {
	ACENN_DEBUG("SAU minimum_matmul_single_1 START!");
    // 1. 直接写入预定义 A_sa, B_sa
    static const int8_t A_sa[256] = {
        -115,-114,-114,-113,-112,-111,-111,-110,-109,-108,-107,-107,-106,-105,-104,-104,
        -103,-102,-101,-100,-100,-99,-98,-97,-97,-96,-95,-94,-93,-93,-92,-91,
        -90,-90,-89,-88,-87,-86,-86,-85,-84,-83,-83,-82,-81,-80,-79,-79,
        -78,-77,-76,-76,-75,-74,-73,-72,-72,-71,-70,-69,-69,-68,-67,-66,
        -65,-65,-64,-63,-62,-62,-61,-60,-59,-58,-58,-57,-56,-55,-55,-54,
        -53,-52,-51,-51,-50,-49,-48,-48,-47,-46,-45,-44,-44,-43,-42,-41,
        -41,-40,-39,-38,-37,-37,-36,-35,-34,-34,-33,-32,-31,-30,-30,-29,
        -28,-27,-27,-26,-25,-24,-23,-23,-22,-21,-20,-20,-19,-18,-17,-16,
        -16,-15,-14,-13,-12,-12,-11,-10,-9,-9,-8,-7,-6,-5,-5,-4,
        -3,-2,-2,-1,0,1,2,2,3,4,5,5,6,7,8,9,
        9,10,11,12,12,13,14,15,16,16,17,18,19,19,20,21,
        22,23,23,24,25,26,26,27,28,29,30,30,31,32,33,33,
        34,35,36,37,37,38,39,40,40,41,42,43,44,44,45,46,
        47,47,48,49,50,51,51,52,53,54,54,55,56,57,58,58,
        59,60,61,61,62,63,64,65,65,66,67,68,68,69,70,71,
        72,72,73,74,75,75,76,77,78,79,79,80,81,82,82,83
    };
    static const int8_t B_sa[256] = {
        109,108,107,107,106,105,105,104,103,103,102,101,101,100,99,99,
        98,97,97,96,95,95,94,93,93,92,91,91,90,89,88,88,
        87,86,86,85,84,84,83,82,82,81,80,80,79,78,78,77,
        76,76,75,74,74,73,72,72,71,70,69,69,68,67,67,66,
        65,65,64,63,63,62,61,61,60,59,59,58,57,57,56,55,
        55,54,53,53,52,51,51,50,49,48,48,47,46,46,45,44,
        44,43,42,42,41,40,40,39,38,38,37,36,36,35,34,34,
        33,32,32,31,30,30,29,28,27,27,26,25,25,24,23,23,
        22,21,21,20,19,19,18,17,17,16,15,15,14,13,13,12,
        11,11,10,9,9,8,7,6,6,5,4,4,3,2,2,1,
        0,0,-1,-2,-2,-3,-4,-4,-5,-6,-6,-7,-8,-8,-9,-10,
        -10,-11,-12,-12,-13,-14,-15,-15,-16,-17,-17,-18,-19,-19,-20,-21,
        -21,-22,-23,-23,-24,-25,-25,-26,-27,-27,-28,-29,-29,-30,-31,-31,
        -32,-33,-34,-34,-35,-36,-36,-37,-38,-38,-39,-40,-40,-41,-42,-42,
        -43,-44,-44,-45,-46,-46,-47,-48,-48,-49,-50,-50,-51,-52,-52,-53,
        -54,-55,-55,-56,-57,-57,-58,-59,-59,-60,-61,-61,-62,-63,-63,-64
    };
    static const int8_t C_ref_int[256] = {
        -13,-13,-12,-12,-12,-11,-11,-11,-11,-10,-10,-10,-9,-9,-9,-9,
        -12,-11,-11,-11,-11,-10,-10,-10,-10,-9,-9,-9,-9,-8,-8,-8,
        -10,-10,-10,-10,-9,-9,-9,-9,-8,-8,-8,-8,-8,-7,-7,-7,
        -9,-9,-9,-8,-8,-8,-8,-8,-7,-7,-7,-7,-7,-6,-6,-6,
        -8,-7,-7,-7,-7,-7,-7,-6,-6,-6,-6,-6,-6,-6,-5,-5,
        -6,-6,-6,-6,-6,-6,-6,-5,-5,-5,-5,-5,-5,-5,-5,-4,
        -5,-5,-5,-5,-5,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,
        -4,-4,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,
        -2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,
        3,3,3,3,3,3,2,2,2,2,2,2,2,2,2,2,
        4,4,4,4,4,4,4,3,3,3,3,3,3,3,2,2,
        6,6,5,5,5,5,5,5,4,4,4,4,4,4,3,3,
        7,7,7,6,6,6,6,6,5,5,5,5,5,4,4,4
    };

    // 将静态数组写入硬件缓冲
    for (int i = 0; i < 256; ++i) {
        input_block1[i] = A_sa[i];
        input_block2[i] = B_sa[i];
        output_block3[i] = 0;
    }

    // 配置寄存器并下发指令
    int32_t a,b,c,d,e,f;
    e = 1;
    int32_t h_ch=1, h_x=1, v_ch=1, v_x=1, o_ch=1, o_x=1;
    int32_t id=0, bias_address=0, flow_loop_times=1;
    int32_t h_addr=(int32_t)(uintptr_t)input_block1;
    int32_t v_addr=(int32_t)(uintptr_t)input_block2;
    int32_t o_addr=(int32_t)(uintptr_t)output_block3;
    int32_t stride_mode=0, transpose_mode=1;
	int32_t cutbit=12, shift_mode=0;
    a = (v_ch<<25)|(v_x<<20)|(v_addr & 0xFFFFF);
    b = (h_ch<<25)|(h_x<<20)|(h_addr & 0xFFFFF);
    c = (o_ch<<25)|(o_x<<20)|(o_addr & 0xFFFFF);
    d = (cutbit<<18)|(shift_mode<<17)|(stride_mode<<16)|(transpose_mode<<14)|(0<<12)
      |(0<<10)|(0<<8)|(0<<6)|flow_loop_times;
    f = (bias_address<<8)|id;
    __kuiloong_ace_msetins1(b,a);
    __kuiloong_ace_msetins2(d,c);
    __kuiloong_ace_msetins3(f,e);

    // 对比
    bool pass=true;
    for(int i=0;i<256;++i){if(output_block3[i]!=C_ref_int[i]){pass=false;ACENN_DEBUG("Mismatch[%d]: ref=%d sa=%d", i, C_ref_int[i], output_block3[i]);}}
    ACENN_DEBUG(pass?"PASS minimum_matmul_multi":"FAIL minimum_matmul_multi");
    asm("ebreak;");
}


void minimum_matmul_multi_1(int8_t *input_block1, int8_t *input_block2, int8_t *output_block3) {
	ACENN_DEBUG("SAU minimum_matmul_multi_1 START!");
    const int H=16, MID=48, W=16;
    static const int8_t A_sa[768] = {
        -96,-96,-96,-95,-95,-95,-95,-94,-94,-94,-94,-94,-93,-93,-93,-93,-93,-92,-92,-92,-92,-91,-91,-91,-91,-91,-90,-90,-90,-90,-89,-89,-89,-89,-89,-88,-88,-88,-88,-88,-87,-87,-87,-87,-86,-86,-86,-86,
        -86,-85,-85,-85,-85,-85,-84,-84,-84,-84,-83,-83,-83,-83,-83,-82,-82,-82,-82,-81,-81,-81,-81,-81,-80,-80,-80,-80,-80,-79,-79,-79,-79,-78,-78,-78,-78,-78,-77,-77,-77,-77,-76,-76,-76,-76,-76,-75,
        -75,-75,-75,-75,-74,-74,-74,-74,-73,-73,-73,-73,-73,-72,-72,-72,-72,-71,-71,-71,-71,-71,-70,-70,-70,-70,-70,-69,-69,-69,-69,-68,-68,-68,-68,-68,-67,-67,-67,-67,-66,-66,-66,-66,-66,-65,-65,-65,
        -65,-65,-64,-64,-64,-64,-63,-63,-63,-63,-63,-62,-62,-62,-62,-62,-61,-61,-61,-61,-60,-60,-60,-60,-60,-59,-59,-59,-59,-58,-58,-58,-58,-58,-57,-57,-57,-57,-57,-56,-56,-56,-56,-55,-55,-55,-55,-55,
        -54,-54,-54,-54,-53,-53,-53,-53,-53,-52,-52,-52,-52,-52,-51,-51,-51,-51,-50,-50,-50,-50,-50,-49,-49,-49,-49,-48,-48,-48,-48,-48,-47,-47,-47,-47,-47,-46,-46,-46,-46,-45,-45,-45,-45,-45,-44,-44,
        -44,-44,-43,-43,-43,-43,-43,-42,-42,-42,-42,-42,-41,-41,-41,-41,-40,-40,-40,-40,-40,-39,-39,-39,-39,-39,-38,-38,-38,-38,-37,-37,-37,-37,-37,-36,-36,-36,-36,-35,-35,-35,-35,-35,-34,-34,-34,-34,
        -34,-33,-33,-33,-33,-32,-32,-32,-32,-32,-31,-31,-31,-31,-30,-30,-30,-30,-30,-29,-29,-29,-29,-29,-28,-28,-28,-28,-27,-27,-27,-27,-27,-26,-26,-26,-26,-25,-25,-25,-25,-25,-24,-24,-24,-24,-24,-23,
        -23,-23,-23,-22,-22,-22,-22,-22,-21,-21,-21,-21,-21,-20,-20,-20,-20,-19,-19,-19,-19,-19,-18,-18,-18,-18,-17,-17,-17,-17,-17,-16,-16,-16,-16,-16,-15,-15,-15,-15,-14,-14,-14,-14,-14,-13,-13,-13,
        -13,-12,-12,-12,-12,-12,-11,-11,-11,-11,-11,-10,-10,-10,-10,-9,-9,-9,-9,-9,-8,-8,-8,-8,-7,-7,-7,-7,-7,-6,-6,-6,-6,-6,-5,-5,-5,-5,-4,-4,-4,-4,-4,-3,-3,-3,-3,-2,
        -2,-2,-2,-2,-1,-1,-1,-1,-1,0,0,0,0,1,1,1,1,1,2,2,2,2,2,3,3,3,3,4,4,4,4,4,5,5,5,5,6,6,6,6,6,7,7,7,7,7,8,8,
        8,8,9,9,9,9,9,10,10,10,10,11,11,11,11,11,12,12,12,12,12,13,13,13,13,14,14,14,14,14,15,15,15,15,16,16,16,16,16,17,17,17,17,17,18,18,18,18,
        19,19,19,19,19,20,20,20,20,21,21,21,21,21,22,22,22,22,22,23,23,23,23,24,24,24,24,24,25,25,25,25,25,26,26,26,26,27,27,27,27,27,28,28,28,28,29,29,
        29,29,29,30,30,30,30,30,31,31,31,31,32,32,32,32,32,33,33,33,33,34,34,34,34,34,35,35,35,35,35,36,36,36,36,37,37,37,37,37,38,38,38,38,39,39,39,39,
        39,40,40,40,40,40,41,41,41,41,42,42,42,42,42,43,43,43,43,43,44,44,44,44,45,45,45,45,45,46,46,46,46,47,47,47,47,47,48,48,48,48,48,49,49,49,49,50,
        50,50,50,50,51,51,51,51,52,52,52,52,52,53,53,53,53,53,54,54,54,54,55,55,55,55,55,56,56,56,56,57,57,57,57,57,58,58,58,58,58,59,59,59,59,60,60,60,
        60,60,61,61,61,61,62,62,62,62,62,63,63,63,63,63,64,64,64,64,65,65,65,65,65,66,66,66,66,66,67,67,67,67,68,68,68,68,68,69,69,69,69,70,70,70,70,70
    };
    static const int8_t B_sa[768] = {
        13,13,12,12,12,12,12,12,11,11,11,11,11,11,10,10,
        10,10,10,10,9,9,9,9,9,9,8,8,8,8,8,8,
        7,7,7,7,7,7,6,6,6,6,6,6,5,5,5,5,
        5,5,4,4,4,4,4,4,3,3,3,3,3,3,2,2,
        2,2,2,2,1,1,1,1,1,1,0,0,0,0,0,0,
        -1,-1,-1,-1,-1,-1,-2,-2,-2,-2,-2,-2,-3,-3,-3,-3,
        -3,-3,-4,-4,-4,-4,-4,-4,-5,-5,-5,-5,-5,-5,-6,-6,
        -6,-6,-6,-6,-7,-7,-7,-7,-7,-7,-8,-8,-8,-8,-8,-8,
        -9,-9,-9,-9,-9,-9,-10,-10,-10,-10,-10,-10,-11,-11,-11,-11,
        -11,-11,-12,-12,-12,-12,-12,-12,-13,-13,-13,-13,-13,-13,-14,-14,
        -14,-14,-14,-14,-15,-15,-15,-15,-15,-15,-16,-16,-16,-16,-16,-16,
        -17,-17,-17,-17,-17,-17,-18,-18,-18,-18,-18,-18,-19,-19,-19,-19,
        -19,-19,-20,-20,-20,-20,-20,-20,-21,-21,-21,-21,-21,-21,-22,-22,
        -22,-22,-22,-22,-23,-23,-23,-23,-23,-23,-24,-24,-24,-24,-24,-24,
        -25,-25,-25,-25,-25,-25,-26,-26,-26,-26,-26,-26,-27,-27,-27,-27,
        -27,-27,-28,-28,-28,-28,-28,-28,-29,-29,-29,-29,-29,-29,-30,-30,
        -30,-30,-30,-30,-31,-31,-31,-31,-31,-31,-32,-32,-32,-32,-32,-32,
        -33,-33,-33,-33,-33,-33,-34,-34,-34,-34,-34,-34,-35,-35,-35,-35,
        -35,-35,-36,-36,-36,-36,-36,-36,-37,-37,-37,-37,-37,-37,-38,-38,
        -38,-38,-38,-38,-39,-39,-39,-39,-39,-39,-40,-40,-40,-40,-40,-40,
        -41,-41,-41,-41,-41,-41,-42,-42,-42,-42,-42,-42,-43,-43,-43,-43,
        -43,-43,-44,-44,-44,-44,-44,-44,-45,-45,-45,-45,-45,-45,-46,-46,
        -46,-46,-46,-46,-47,-47,-47,-47,-47,-47,-48,-48,-48,-48,-48,-48,
        -49,-49,-49,-49,-49,-49,-50,-50,-50,-50,-50,-50,-51,-51,-51,-51,
        -51,-51,-52,-52,-52,-52,-52,-52,-53,-53,-53,-53,-53,-53,-54,-54,
        -54,-54,-54,-54,-55,-55,-55,-55,-55,-55,-56,-56,-56,-56,-56,-56,
        -57,-57,-57,-57,-57,-57,-58,-58,-58,-58,-58,-58,-59,-59,-59,-59,
        -59,-59,-60,-60,-60,-60,-60,-60,-61,-61,-61,-61,-61,-61,-62,-62,
        -62,-62,-62,-62,-63,-63,-63,-63,-63,-63,-64,-64,-64,-64,-64,-64,
        -65,-65,-65,-65,-65,-65,-66,-66,-66,-66,-66,-66,-67,-67,-67,-67,
        -67,-67,-68,-68,-68,-68,-68,-68,-69,-69,-69,-69,-69,-69,-70,-70,
        -70,-70,-70,-70,-71,-71,-71,-71,-71,-71,-72,-72,-72,-72,-72,-72,
        -73,-73,-73,-73,-73,-73,-74,-74,-74,-74,-74,-74,-75,-75,-75,-75,
        -75,-75,-76,-76,-76,-76,-76,-76,-77,-77,-77,-77,-77,-77,-78,-78,
        -78,-78,-78,-78,-79,-79,-79,-79,-79,-79,-80,-80,-80,-80,-80,-80,
        -81,-81,-81,-81,-81,-81,-82,-82,-82,-82,-82,-82,-83,-83,-83,-83,
        -83,-83,-84,-84,-84,-84,-84,-84,-85,-85,-85,-85,-85,-85,-86,-86,
        -86,-86,-86,-86,-87,-87,-87,-87,-87,-87,-88,-88,-88,-88,-88,-88,
        -89,-89,-89,-89,-89,-89,-90,-90,-90,-90,-90,-91,-91,-91,-91,-91,
        -91,-92,-92,-92,-92,-92,-92,-93,-93,-93,-93,-93,-93,-94,-94,-94,
        -94,-94,-94,-95,-95,-95,-95,-95,-95,-96,-96,-96,-96,-96,-96,-97,
        -97,-97,-97,-97,-97,-98,-98,-98,-98,-98,-98,-99,-99,-99,-99,-99,
        -99,-100,-100,-100,-100,-100,-100,-101,-101,-101,-101,-101,-101,-102,-102,-102,
        -102,-102,-102,-103,-103,-103,-103,-103,-103,-104,-104,-104,-104,-104,-104,-105,
        -105,-105,-105,-105,-105,-106,-106,-106,-106,-106,-106,-107,-107,-107,-107,-107,
        -107,-108,-108,-108,-108,-108,-108,-109,-109,-109,-109,-109,-109,-110,-110,-110,
        -110,-110,-110,-111,-111,-111,-111,-111,-111,-112,-112,-112,-112,-112,-112,-113,
        -113,-113,-113,-113,-113,-114,-114,-114,-114,-114,-114,-115,-115,-115,-115,-115
    };
    static const int8_t C_ref_int[256] = {
        51,52,52,52,52,52,52,53,53,53,53,53,54,54,54,54,
        45,45,46,46,46,46,46,46,47,47,47,47,47,47,48,48,
        39,39,39,40,40,40,40,40,40,40,41,41,41,41,41,41,
        33,33,33,33,34,34,34,34,34,34,34,34,35,35,35,35,
        27,27,27,27,27,28,28,28,28,28,28,28,28,28,28,28,
        21,21,21,21,21,21,21,21,22,22,22,22,22,22,22,22,
        15,15,15,15,15,15,15,15,15,15,15,15,15,16,16,16,
        9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
        3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
        -3,-3,-3,-3,-3,-3,-3,-3,-3,-4,-4,-4,-4,-4,-4,-4,
        -10,-10,-10,-10,-10,-10,-10,-10,-10,-10,-10,-10,-10,-10,-10,-10,
        -16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,-16,
        -22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-22,-23,-23,-23,-23,
        -28,-28,-28,-28,-28,-28,-28,-28,-29,-29,-29,-29,-29,-29,-29,-29,
        -34,-34,-34,-34,-34,-34,-35,-35,-35,-35,-35,-35,-35,-35,-35,-36,
        -40,-40,-40,-40,-41,-41,-41,-41,-41,-41,-41,-41,-42,-42,-42,-42
    };
    // 写入缓冲
    for(int i=0;i<768;++i) input_block1[i]=A_sa[i];
    for(int i=0;i<768;++i) input_block2[i]=B_sa[i];
    for(int i=0;i<256;++i) output_block3[i]=0;
    // 配置寄存器
    int32_t a,b,c,d,e,f;
    e=1;
    int32_t h_ch=0,h_x=3,v_ch=16,v_x=1,o_ch=1,o_x=1;  //h_ch到底是1还是0？
    int32_t id=0,bias_address=0,flow_loop_times=3;
    int32_t h_addr=(int32_t)(uintptr_t)input_block1;
    int32_t v_addr=(int32_t)(uintptr_t)input_block2;
    int32_t o_addr=(int32_t)(uintptr_t)output_block3;
    int32_t stride_mode=0,transpose_mode=1;
    int32_t cutbit=12, shift_mode=0;
    a=(v_ch<<25)|(v_x<<20)|(v_addr & 0xFFFFF);
    b=(h_ch<<25)|(h_x<<20)|(h_addr & 0xFFFFF);
    c=(o_ch<<25)|(o_x<<20)|(o_addr & 0xFFFFF);
    d=(cutbit<<18)|(shift_mode<<17)|(stride_mode<<16)|(transpose_mode<<14)|(0<<12)|(0<<10)|(2<<8)|(0<<6)|flow_loop_times;
    f=(bias_address<<8)|id;
    __kuiloong_ace_msetins1(b,a);
    __kuiloong_ace_msetins2(d,c);
    __kuiloong_ace_msetins3(f,e);


    d=(cutbit<<18)|(shift_mode<<17)|(stride_mode<<16)|(transpose_mode<<14)|(0<<12)|(0<<10)|(0<<8)|(0<<6)|flow_loop_times;
	__kuiloong_ace_msetins1(b,a);
    __kuiloong_ace_msetins2(d,c);
    __kuiloong_ace_msetins3(f,e);

    bool pass=true;
    for(int i=0;i<256;++i){if(output_block3[i]!=C_ref_int[i]){pass=false;ACENN_DEBUG("Mismatch[%d]: ref=%d sa=%d", i, C_ref_int[i], output_block3[i]);}}
    ACENN_DEBUG(pass?"PASS minimum_matmul_multi":"FAIL minimum_matmul_multi");
    asm("ebreak;");
}


void minimum_matmul_single(int8_t *input_block1, int8_t *input_block2, int8_t *output_block3) {
	ACENN_DEBUG("SAU minimum_matmul_single START!");
	// 1. 生成测试矩阵 A(16×16), B(16×16)，值域限制在 int8 [-128,127]
    int8_t A[16][16], B[16][16], C_ref[16][16];
    for (int i = 0; i < 16; i++) {
        for (int j = 0; j < 16; j++) {
            int idx = i * 16 + j;
            A[i][j] = int8_t(idx - 128);
            B[i][j] = int8_t((255 - idx) - 128);  // =127-idx
        }
    }
    // 2. CPU 参考实现 C_ref = A×B
    for (int i = 0; i < 16; i++) {
        for (int j = 0; j < 16; j++) {
            int32_t sum = 0;
            for (int k = 0; k < 16; k++) {
				sum += A[i][k] * B[k][j];
				// ACENN_DEBUG("A[%d][%d] * B[%d][%d] = %d * %d = %d", i, k, k, j, A[i][k], B[k][j], A[i][k] * B[k][j]);
			}
            C_ref[i][j] = int8_t(sum);
        }
    }

	// 【3】拷贝到硬件缓冲并清零输出
	for (int i = 0; i < 256; i++) {
		input_block1[i] = ((int8_t*)A)[i];
		input_block2[i] = ((int8_t*)B)[i];
		output_block3[i] = 0;
	}

	// 4. 按例程顺序配置 a-f 寄存器字段
    int32_t a, b, c, d, e, f;
    // e = start flag, 0x1 为启动标志
    f = 0x00000001;
    // 通道与步长配置
    int32_t h_ch = 0, h_x = 1;
    int32_t v_ch = 0, v_x = 1;
    int32_t o_ch = 0, o_x = 1;
    int32_t id = 0;
    int32_t bias_address = 0;
    int32_t flow_loop_times = 1;
    // 基址偏移
    int32_t h_addr = (int32_t)(uintptr_t)input_block1;
    int32_t v_addr = (int32_t)(uintptr_t)input_block2;
    int32_t o_addr = (int32_t)(uintptr_t)output_block3;
    // 模式字段
    int32_t stride_mode = 0;
    int32_t transpose_mode = 1;
    int32_t conv_kernel = 0;
    int32_t register_mode = 0;
    int32_t flow_mode = 0;
    int32_t work_mode = 0;

    // 组装 a-f
    a = (h_ch << 25) | (h_x << 20) | h_addr;
    b = (v_ch << 25) | (v_x << 20) | v_addr;
    c = (stride_mode << 16)
      | (transpose_mode << 14)
      | (conv_kernel << 12)
      | (register_mode << 10)
      | (flow_mode << 8)
      | (work_mode << 6)
      | flow_loop_times;
    d = (o_ch << 25) | (o_x << 20) | o_addr;
	e = (bias_address << 8) | id;

    // 5. 下发指令：直接传入 int32_t a–f
    __kuiloong_ace_msetins1(a, b);
    __kuiloong_ace_msetins2(c, d);
    __kuiloong_ace_msetins3(e, f);

	// 6. 等待硬件完成（可加循环查询状态寄存器，此处假设立即完成）

	// 7. 验证结果
	int errors = 0;
	for (int i = 0; i < 16; i++) {
		for (int j = 0; j < 16; j++) {
			int8_t hw = output_block3[i*16 + j];
			int8_t sw = C_ref[i][j];
			if (hw != sw) {
				errors++;
				ACENN_DEBUG("Mismatch at [%d][%d]: hw=%d, sw=%d\n", i, j, hw, sw);
			}
		}
	}
	if (errors == 0) {
		ACENN_DEBUG("PASS: Hardware result matches reference.\n");
	} else {
		ACENN_DEBUG("FAIL: %d mismatches found.\n", errors);
	}
	asm("ebreak;"); // 中断，停止运行
}

void minimum_pwconv_single(int8_t *input_block1, int8_t *input_block2, int8_t *output_block3) {
	ACENN_DEBUG("SAU minimum_pwconv_single START!");
    // 1. 直接写入预定义 Active, Weight, Result 数组到 input_block1, input_block2, output_block3
    static const int8_t Active[512] = {
    -115,-114,-114,-113,-112,-111,-111,-110,-109,-108,-107,-107,-106,-105,-104,-104,
    -103,-102,-101,-100,-100,-99,-98,-97,-97,-96,-95,-94,-93,-93,-92,-91,
    -90,-90,-89,-88,-87,-86,-86,-85,-84,-83,-83,-82,-81,-80,-79,-79,
    -78,-77,-76,-76,-75,-74,-73,-72,-72,-71,-70,-69,-69,-68,-67,-66,
    -65,-65,-64,-63,-62,-62,-61,-60,-59,-58,-58,-57,-56,-55,-55,-54,
    -53,-52,-51,-51,-50,-49,-48,-48,-47,-46,-45,-44,-44,-43,-42,-41,
    -41,-40,-39,-38,-37,-37,-36,-35,-34,-34,-33,-32,-31,-30,-30,-29,
    -28,-27,-27,-26,-25,-24,-23,-23,-22,-21,-20,-20,-19,-18,-17,-16,
    -16,-15,-14,-13,-12,-12,-11,-10,-9,-9,-8,-7,-6,-5,-5,-4,
    -3,-2,-2,-1,0,1,2,2,3,4,5,5,6,7,8,9,
    9,10,11,12,12,13,14,15,16,16,17,18,19,19,20,21,
    22,23,23,24,25,26,26,27,28,29,30,30,31,32,33,33,
    34,35,36,37,37,38,39,40,40,41,42,43,44,44,45,46,
    47,47,48,49,50,51,51,52,53,54,54,55,56,57,58,58,
    59,60,61,61,62,63,64,65,65,66,67,68,68,69,70,71,
    72,72,73,74,75,75,76,77,78,79,79,80,81,82,82,83,

    -115,-114,-114,-113,-112,-111,-111,-110,-109,-108,-107,-107,-106,-105,-104,-104,
    -103,-102,-101,-100,-100,-99,-98,-97,-97,-96,-95,-94,-93,-93,-92,-91,
    -90,-90,-89,-88,-87,-86,-86,-85,-84,-83,-83,-82,-81,-80,-79,-79,
    -78,-77,-76,-76,-75,-74,-73,-72,-72,-71,-70,-69,-69,-68,-67,-66,
    -65,-65,-64,-63,-62,-62,-61,-60,-59,-58,-58,-57,-56,-55,-55,-54,
    -53,-52,-51,-51,-50,-49,-48,-48,-47,-46,-45,-44,-44,-43,-42,-41,
    -41,-40,-39,-38,-37,-37,-36,-35,-34,-34,-33,-32,-31,-30,-30,-29,
    -28,-27,-27,-26,-25,-24,-23,-23,-22,-21,-20,-20,-19,-18,-17,-16,
    -16,-15,-14,-13,-12,-12,-11,-10,-9,-9,-8,-7,-6,-5,-5,-4,
    -3,-2,-2,-1,0,1,2,2,3,4,5,5,6,7,8,9,
    9,10,11,12,12,13,14,15,16,16,17,18,19,19,20,21,
    22,23,23,24,25,26,26,27,28,29,30,30,31,32,33,33,
    34,35,36,37,37,38,39,40,40,41,42,43,44,44,45,46,
    47,47,48,49,50,51,51,52,53,54,54,55,56,57,58,58,
    59,60,61,61,62,63,64,65,65,66,67,68,68,69,70,71,
    72,72,73,74,75,75,76,77,78,79,79,80,81,82,82,83
    };
    static const int8_t Weight[512] = {
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8
    };
    static const int8_t Result[256] = {
    2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,
    5,5,5,4,4,4,4,4,3,3,3,3,3,2,2,2,
    8,7,7,7,7,6,6,6,5,5,5,4,4,4,4,3,
    10,10,10,9,9,8,8,8,7,7,7,6,6,5,5,5,
    13,13,12,12,11,11,10,10,9,9,8,8,7,7,6,6,
    16,15,15,14,14,13,12,12,11,11,10,9,9,8,8,7,
    19,18,17,17,16,15,15,14,13,12,12,11,10,10,9,8,
    21,21,20,19,18,17,17,16,15,14,14,13,12,11,10,10,
    -3,-3,-3,-3,-3,-3,-3,-3,-2,-2,-2,-2,-2,-2,-2,-2,
    -6,-6,-6,-5,-5,-5,-5,-5,-4,-4,-4,-4,-4,-3,-3,-3,
    -9,-8,-8,-8,-8,-7,-7,-7,-6,-6,-6,-5,-5,-5,-5,-4,
    -11,-11,-11,-10,-10,-9,-9,-9,-8,-8,-8,-7,-7,-6,-6,-6,
    -14,-14,-13,-13,-12,-12,-11,-11,-10,-10,-9,-9,-8,-8,-7,-7,
    -17,-16,-16,-15,-15,-14,-13,-13,-12,-12,-11,-10,-10,-9,-9,-8,
    -20,-19,-18,-18,-17,-16,-16,-15,-14,-13,-13,-12,-11,-11,-10,-9,
    -22,-22,-21,-20,-19,-18,-18,-17,-16,-15,-15,-14,-13,-12,-11,-11
    };
        // 将静态数组写入硬件缓冲
    for (int i = 0; i < 512; ++i) {
        input_block1[i] = Active[i];
        input_block2[i] = Weight[i];
        output_block3[i] = 0;
    }
    
    
    // 4. 按例程顺序配置 a-f 寄存器字段
    int32_t a, b, c, d, e, f;
    // e = start flag, 0x1 为启动标志
    f = 0x00000001;
    // 通道与步长配置
    int32_t h_ch = 16, h_x = 1;
    int32_t v_ch = 16, v_x = 1;
    int32_t o_ch = 1, o_x = 1;
    int32_t id = 0;
    int32_t bias_address = 0;
    int32_t flow_loop_times = 2;
    // 基址偏移
    int32_t h_addr = (int32_t)(uintptr_t)input_block1;
    int32_t v_addr = (int32_t)(uintptr_t)input_block2;
    int32_t o_addr = (int32_t)(uintptr_t)output_block3;
    // 模式字段
    int32_t stride_mode = 0;
    int32_t transpose_mode = 0;
    int32_t conv_kernel = 1;
    int32_t register_mode = 0;
    int32_t flow_mode = 1;
    int32_t work_mode = 0;
    int32_t cutbit=8, shift_mode=0;
    // 组装 a-f
    a = (h_ch << 25) | (h_x << 20) | (h_addr & 0xFFFFF);
    b = (v_ch << 25) | (v_x << 20) | (v_addr & 0xFFFFF);
    c = (cutbit<<18)
      | (shift_mode<<17)
      | (stride_mode << 16)
      | (transpose_mode << 14)
      | (conv_kernel << 12)
      | (register_mode << 10)
      | (flow_mode << 8)
      | (work_mode << 6)
      | flow_loop_times;
    d = (o_ch << 25) | (o_x << 20) | (o_addr & 0xFFFFF);
	e = (bias_address << 8) | id;

    // 5. 下发指令：直接传入 int32_t a–f
    __kuiloong_ace_msetins1(a, b);
    __kuiloong_ace_msetins2(c, d);
    __kuiloong_ace_msetins3(e, f);

	// 6. 对比处理结果
	bool pass=true;
    for(int i=0;i<256;++i){if(output_block3[i]!=Result[i]){pass=false;ACENN_DEBUG("Mismatch[%d]: ref=%d sa=%d", i, Result[i], output_block3[i]);}}
    ACENN_DEBUG(pass?"PASS minimum_matmul_multi":"FAIL minimum_matmul_multi");
}

void minimum_conv_single(int8_t *input_block1, int8_t *input_block2, int8_t *output_block3, int8_t *input_block4) {
	ACENN_DEBUG("SAU minimum_conv_single START!");
    // 1. 直接写入预定义 Active, Weight, Result 数组到 input_block1, input_block2, output_block3
    static const int8_t Active[432] = {
        -115,-114,-114,-113,-112,-111,-111,-110,-109,-108,-107,-107,-106,-105,-104,-104,
        88,88,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,

        -103,-102,-101,-100,-100,-99,-98,-97,-97,-96,-95,-94,-93,-93,-92,-91,
        77,77,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,

        -90,-90,-89,-88,-87,-86,-86,-85,-84,-83,-83,-82,-81,-80,-79,-79,
        66,66,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,


        11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
        11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
        11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,

        11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
        11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
        11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,

        11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
        11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
        11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,

        -88,-88,-114,-113,-112,-111,-111,-110,-109,-108,-107,-107,-106,-105,-104,-104,
        88,88,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
        -77,-77,-101,-100,-100,-99,-98,-97,-97,-96,-95,-94,-93,-93,-92,-91,
        77,77,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
        -66,-66,-89,-88,-87,-86,-86,-85,-84,-83,-83,-82,-81,-80,-79,-79,
        66,66,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11
    };
    static const int8_t Weight[512] = {
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        -1,-2,-3,-4,-5,-6,-7,-8,1,2,3,4,5,6,7,8,
        0 ,0 ,0 , 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,
        0 ,0 ,0 , 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,
        0 ,0 ,0 , 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,
        0 ,0 ,0 , 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,
        0 ,0 ,0 , 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,
        0 ,0 ,0 , 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,
        0 ,0 ,0 , 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,

        1,2,3,4,5,6,7,8,-1,-2,-3,-4,-5,-6,-7,-8,
        1,2,3,4,5,6,7,8,-1,-2,-3,-4,-5,-6,-7,-8,
        1,2,3,4,5,6,7,8,-1,-2,-3,-4,-5,-6,-7,-8,
        1,2,3,4,5,6,7,8,-1,-2,-3,-4,-5,-6,-7,-8,
        1,2,3,4,5,6,7,8,-1,-2,-3,-4,-5,-6,-7,-8,
        1,2,3,4,5,6,7,8,-1,-2,-3,-4,-5,-6,-7,-8,
        1,2,3,4,5,6,7,8,-1,-2,-3,-4,-5,-6,-7,-8,
        1,2,3,4,5,6,7,8,-1,-2,-3,-4,-5,-6,-7,-8,
        1,2,3,4,5,6,7,8,-1,-2,-3,-4,-5,-6,-7,-8,
        0 ,0 ,0 , 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,
        0 ,0 ,0 , 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,
        0 ,0 ,0 , 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,
        0 ,0 ,0 , 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,
        0 ,0 ,0 , 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,
        0 ,0 ,0 , 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0,
        0 ,0 ,0 , 0, 0, 0, 0, 0,0,0,0,0,0,0,0,0
    };

    static const int8_t Bias[16] = {
    2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1
    };
    static const int8_t Result[256] = {
    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
    3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
    3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
    4,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
    4,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
    5,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
    6,4,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
    6,4,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    -1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    -1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    -2,-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    -2,-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    -3,-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    -4,-2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    -4,-2,1,1,1,1,1,1,1,1,1,1,1,1,1,1
    };
    static const int8_t Result_stride[256] = {
    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
    3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
    3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
    4,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
    4,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
    5,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
    6,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
    6,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
    0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    -1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    -1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    -2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    -2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    -3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    -4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    -4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
    };


        // 将静态数组写入硬件缓冲
    for (int i = 0; i < 432; ++i) {
        input_block1[i] = Active[i];
    }
    for (int j = 0; j < 512; ++j) {
        input_block2[j] = Weight[j];
        output_block3[j] = 0;
    }
    for (int k = 0; k < 32; ++k) {
        input_block4[k] = Bias[k];
    }

    // 4. 按例程顺序配置 a-f 寄存器字段
    int32_t a, b, c, d, e, f;
    // e = start flag, 0x1 为启动标志
    f = 0x00000001;
    // 通道与步长配置
    int32_t h_ch = 6, h_x = 3;
    int32_t v_ch = 16, v_x = 1;
    int32_t o_ch = 1, o_x = 1;
    int32_t id = 0;
    int32_t flow_loop_times = 2;
    // 基址偏移
    int32_t h_addr = (int32_t)(uintptr_t)input_block1;
    int32_t v_addr = (int32_t)(uintptr_t)input_block2;
    int32_t o_addr = (int32_t)(uintptr_t)output_block3;
    int32_t b_addr = (int32_t)(uintptr_t)input_block4;
    // 模式字段
    int32_t stride_mode = 1;
    int32_t transpose_mode = 0;
    int32_t conv_kernel = 3;
    int32_t register_mode = 0;
    int32_t flow_mode = 1;
    int32_t work_mode = 2;
    int32_t cutbit=8, shift_mode=0;
    // 组装 a-f
    a = (h_ch << 25) | (h_x << 20) | (h_addr & 0xFFFFF);
    b = (v_ch << 25) | (v_x << 20) | (v_addr & 0xFFFFF);
    c = (cutbit<<18)
      | (shift_mode<<17)
      | (stride_mode << 16)
      | (transpose_mode << 14)
      | (conv_kernel << 12)
      | (register_mode << 10)
      | (flow_mode << 8)
      | (work_mode << 6)
      | flow_loop_times;
    d = (o_ch << 25) | (o_x << 20) | (o_addr & 0xFFFFF);
	e = ((b_addr & 0xFFFFF) << 8) | id;

    // 5. 下发指令：直接传入 int32_t a–f
    __kuiloong_ace_msetins1(a, b);
    __kuiloong_ace_msetins2(c, d);
    __kuiloong_ace_msetins3(e, f);

	bool pass=true;
    if(stride_mode==0){
        for(int i=0;i<256;++i){if(output_block3[i]!=Result[i]){pass=false;ACENN_DEBUG("Mismatch[%d]: ref=%d sa=%d", i, Result[i], output_block3[i]);}}
    }else{
        for(int i=0;i<256;++i){if(output_block3[i]!=Result_stride[i]){pass=false;ACENN_DEBUG("Mismatch[%d]: ref=%d sa=%d", i, Result_stride[i], output_block3[i]);}}
    }
    ACENN_DEBUG(pass?"PASS minimum_matmul_multi":"FAIL minimum_matmul_multi");

}


void sau_benchmark(int8_t *input_block1, int8_t *input_block2, int8_t *output_block3, int8_t *input_block4)
{
	ACENN_DEBUG("SAU BENCHMARK START!");

	// matrix_csr_set_test();

	// minimum_matmul_single_1(input_block1, input_block2, output_block3);

	// minimum_pwconv_single(input_block1, input_block2, output_block3);

    minimum_conv_single(input_block1, input_block2, output_block3, input_block4);

	ACENN_DEBUG("SAU BENCHMARK PASS!");
}

